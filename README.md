# รายงานวิชาCN210
## สรุปเนื้อหาการบ้านครั้งที่ 1
**MIPS Instruction format**
MIPS คอมพิวเตอร์ชนิด RISC ผลิตโดย MIPS Technologies ซึ่งในทุกๆคำสั่งของ MIPS จะมีขนาด 32 bit ประกอบด้วย 3 ชนิดด้วยกัน คือ
**R-Format** -เป็นคำสั่งที่ใช้ดำเนินการทางคณิตศาสตร์และตรรกศาสตร์ มีโครงสร้างต่อไปนี้

|**R-Format**|     |     |     |     |     |
|------------|-----|-----|-----|-----|-----|
|     op     | $rs | $rt | $rd |shamt|func |
|     6bit   | 5bit| 5bit| 5bit|5bit |6bit |

|**คำสั่ง**    |     |     |     |     |     |
|------------|-----|-----|-----|-----|-----|
|ALU         | alu | $rd | $rs | $rt |     |
|JR          | jr  | $rs |     |     |     |

สำหรับ R-Format นั้นส่วนใหญ่จะเป็นคำสั่งทางคณิตศาสตร์ เช่น คำสั่ง add เพื่อบวกกัน sub เพื่อลบ
โดยขั้นตอนในการทำคำสั่ง ADD นั้นจะมีดังนี้
1. ทำการอ่าน op-code ซึ่งสำหรับ R-Format จะเป็น 000000
2. เช็คว่า func มีค่าเป็นอะไรเช่น หาก func มีค่าเป็น 100000 จะเป็นคำสั่ง ADD
3. จากตัวอย่างที่ยกมา ให้ค่า func เป็นคำสั่ง ADD จะทำการบวกกันโดยนำค่าที่เก็บอยู่ใน $rs และ $rt มาทำการบวกกัน หลังจากนั้นนำผลลัพธ์ที่ได้ไปเก็บใน $rd

**I-Format** -เป็นคำสั่งที่ใช้ย้ายข้อมูล

|**I-Format**|     |     |     |
|------------|-----|-----|-----|
|     op     | $rs | $rt | offset |
|     6bit   | 5bit| 5bit| 16bit  |

|**คำสั่ง**    |     |     |        |         | 
|------------|-----|-----|---------|--------|
|ALUi        |alui | $rt | $rs     | value   |
|Data Transfer | lw | $rt | offset($rs)  |   |
|             |  sw | $rt | offset($rs)  |   |
|Branch      |  beq | $rs | $rt | offset |   | 


**J-Format** -เป็นคำสั่งสำหรับ jump จาก Address ปัจจุบัน ไปยังอีกตำแหน่งนึง

|**J-Format**|     |
|------------|-----|
|     op     | Address |
|     6bit   | 26bit|

|**คำสั่ง**    |           |
|------------|------------|
| jump       |  j address|
| jump&link  |jal address|

### งานครั้งที่ 1
  [คลิปงานครั้งที่ 1 อธิบายรูปแบบคำสั่ง R-FORMAT](https://www.youtube.com/watch?v=uxKd0FtUXx8&t=9s)

## สรุปเนื้อหาการบ้านครั้งที่ 2
**การทำงานของ CPU**
ภาษาที่มนุษย์ใช้สื่อสารกับคอมพิวเตอร์เช่น JAVA,Python,C++ นั้นจริงๆแล้วคอมพิวเตอร์จะทำการแปลง คำสั่งต่างๆที่เราเขียนผ่านภาษาเหล่านี้ เป็นภาษาคอมพิวเตอร์ก่อน 

###### คำสั่งที่มนุษย์ใช้สื่อสาร/สั่งการคอมพิวเตอร์ 
    public class Test{
        public static void (String[]args){
              int a = 10;
              int b = 20;
              int c = a + b; 
        }
    } 

ภาษาข้างบนนั้นเป็นภาษา Java หากภาษาที่คอมพิวเตอร์สามารถเข้าใจหรือ Machine Language จะเป็น 
                >00000000:           08400000  

ซึ่งแปลความได้ว่า  j  01000000  คอมพิวเตอร์ MIPS จะมีขั้นตอนการดำเนินคำสั่งตามตัวอย่างต่อไปนี้
1. เมื่อผู้ใช้ทำการเปิดคอมพิวเตอร์ คอมพิวเตอร์จะมาที่ address ที่ 00000000 เพื่ออ่านคำสั่งซึ่งก็คือ คำสั่ง 08400000 เป็นเลขฐาน 16
2. MIPS จะทำการเปลี่ยนคำสั่งเลขฐาน 16 เป็นเลขฐาน 2 จะได้ 00001000010000000000000000000000
3. Decoder ทำการอ่านคำสั่งที่แปลงเป็นเลขฐาน 2 โดยจะเริ่มอ่าน 6 บิทแรกก่อน จากตัวอย่างคือ 000010 เป็น J-Format
4. 26 บิทที่เหลือคือตำแหน่ง Address ที่จะทำการ JUMP โดยนำเลข 26 บิทนั้นมาเติม 0 ข้างหน้า 4 ตัวและข้างหลัง 2 ตัว จะได้ Address ที่มีขนาด 32 บิท
นั่นก็คือ Address 01000000

                00000004:           1A000000
                
5. Address ถัดมาจะลงท้ายด้วย 4 เนื่องจาก 1 คำสั่งมีขนาด 4 byte 
6. คอมพิวเตอร์ได้ทำการ JUMP มาที่ Address 01000000 ซึ่งมีคำสั่ง 8C090004 ดังบรรทัดด้านล่าง

                01000000:           8C090004


7. คอมพิวเตอร์จะทำการแปลงคำสั่งเลขฐาน 16 ให้เป็นเลขฐาน 2 ได้ 0001100000010010000000000000100
8. Decoder ทำการอ่าน 6 bit แรกคือ 000110 พบว่าเป็น I-Format คำสั่ง lw (load word) 5 bits ถัดมาคือ 00000 คือ $rs=0 5 bits ถัดมาคือ 01001 $rt=9 และ    16 bits ที่เหลือคือ 0000000000000100 หมายความว่า offset = 4 ซึ่งหลักการของ lw นั้นคือการ นำค่า offset ไปบวกกับ $rs จะได้ Address ที่ต้องไปดึงข้อมูลออก    มาอ่านและเก็บ ใน $rt 

### งานครั้งที่ 2
  [คลิปงานครั้งที่ 2 อธิบายหลักการทำงานของ CPU](https://www.youtube.com/watch?v=afBzikgJ6VA)



## สรุปเนื้อหาการบ้านครั้งที่ 3
 **ความแตกต่างระหว่าง Single Cycle และ Multi Cycle**
 ![singlecycle](https://slideplayer.com/slide/4943101/16/images/5/Single+Cycle+Implementation.jpg)
 ##### ลักษณะของ Single Cycle มีดังนี้
    - มี ALU 3 ตัว
    - มี Memory 2 ตัว
    - 1 คำสั่ง = 1 Cycle
    - ในทุกๆคำสั่งใช้เวลาเท่ากันทำให้ใช้เวลามากเนื่องจากจะใช้เวลาของคำสั่งที่ทำงานใช้เวลามากสุด
    
![multicycle](https://people.cs.pitt.edu/~don/coe1502/current/Unit4a/fig548.jpg)
##### ลักษณะของ Multi Cycle มีดังนี้
    - มี ALU เพียงตัวเดียว
    - มี Memory เพียงตัวเดียว
    - มีการพักข้อมูลที่ตำแหน่ง a และ b ในรูป
    - ใช้เวลาแต่ละคำสั่งไม่เท่ากัน
    - มี ALUout ที่เก็บค่าหลังจากคำนวณ
  ### งานครั้งที่ 3
  [คลิปงานครั้งที่ 3 อธิบายความแตกต่างระหว่าง Single Cycle และ Multi Cycle](https://www.youtube.com/watch?v=D7P8hxrkiEY)
  
  
## สรุปเนื้อหาการบ้านครั้งที่ 4
 **การทำงานของคำสั่ง lw ใน Multi Cycle**
 ![multicycle](https://people.cs.pitt.edu/~don/coe1502/current/Unit4a/fig548.jpg)
 
 **คำสั่ง lw ใน Multi Cycle นั้นมีทั้งหมด 5 ขั้นตอนด้วยกัน**
 1. อ่านคำสั่งจาก Memory มาเก็บใน IR (Instruction Register) และนำ PC = PC + 4 พร้อมๆกัน
 2. นำ ค่าจาก $rs และ $rt ไปเก็บไว้ที่ A,B ตามลำดับ นำค่า offset มาแปลงเป็น 32 บิทแล้วนำไปที่ ALU เพื่อบวกกับ PC แล้วนำไปเก็บที่ ALUout 
 (A = Reg[IR[25-21]]) (B = Reg[IR[20-16]])
 3. นำค่า จาก A เข้ามาบวกกับ offset และนำค่าไปไว้ที่ ALUout (ALUOut = A + sign-extend(IR[15-0])
 4. ค่าที่ได้จาก ALUout คือ ค่าของ Address ของ Memory ที่จะถูกอ่านค่าออกมา (MDR = Memory[ALUout])
 5. นำค่าที่อ่านมาจาก Memory ไปเก็บไว้ใน $rt (Reg[IR[20-16]] = MDR)

  ### งานครั้งที่ 4
  [คลิปงานครั้งที่ 4 การทำงานคำสั่ง lw ใน Multi Cycle](https://www.youtube.com/watch?v=dOmY8EDUxi0&t=19s)
  
## สรุปเนื้อหาการบ้านครั้งที่ 5
  **การทำงานของคำสั่ง beq ใน Multi Cycle**
  ![multicycle](https://people.cs.pitt.edu/~don/coe1502/current/Unit4a/fig548.jpg)
  
  **คำสั่ง beq ใน Multi Cycle นั้นมีทั้งหมด 3 ขั้นตอนด้วยกัน**
สำหรับ beq หรือ branch on equal นั้นเป็นคำสั่งประเภื I-Format ซึ่งคำสั่งนี้มีหน้าที่ JUMP โดยจะ JUMP อย่างมีเงื่อนไข คือการดูว่าข้อมูลที่ $rs และ $rt เท่ากันหรือไม่ หากเท่ากันให้ JUMP ไปยังตำแหน่ง Address ต่อไป ซึ่งทั้ง 3 ขั้นตอนนั้นมีดังนี้

1. อ่านคำสั่งจาก Memory มาเก็บใน IR (Instruction Register) และนำ PC = PC + 4 พร้อมๆกัน เหมือนกับคำสั่ง lw ข้อที่แล้ว
2. นำค่า $rs และ $rt ไปเก็บไว้ที่ A,B ตามลำดับ (A = Reg[IR[25-21]]) (B = Reg[IR[20-16]])
3. นำค่าจาก A และ B มาเปรียบเทียบกัน หากเท่ากันจะเก็บผลลัพธ์ที่ได้ไว้ใน ALUout แล้ว JUMP ไปยัง Address ต่อไป หากไม่เท่ากันจะข้ามไปทำคำสั่งถัดไปทันที
  
   ### งานครั้งที่ 5
  [คลิปงานครั้งที่ 5 การทำงานของคำสั่ง beq ใน Multi Cycle](https://www.youtube.com/watch?v=IAmkzRGe4yQ&t=14s)
  
  
## สรุปเนื้อหาการบ้านครั้งที่ 6
  **State Machine ของ คำสั่งชนิด R-Format**
  ![statemachine](https://image3.slideserve.com/5922537/the-four-stages-of-r-type-l.jpg)
  #### มีทั้งหมด 4 Cycle ด้วยกันดังนี้
  ### Cycle 1 Instruction Fetch
  ![stateno1](https://image1.slideserve.com/3211244/slide21-n.jpg)
  
  **จากรูปภาพ ตัวหนังสือสีแดง แสดงถึงส่วนที่ทำใน Cycle นี้ ตัวหนังสือสีดำ แสดงถึงส่วนที่ไม่ได้ทำใน Cycle นี้** 
  
  <br>MemRead = 1 คือ ทำการอ่านค่าจาก Memory
  <br>IorD    = 1 คือ เช็คว่า PC นั้นชี้ไปที่ Address ใดใน Memory
  <br>IRWrite = 1 คือ นำค่าจาก Address Memory ที่ถูกชี้ ไปเก็บไว้ใน IR
  <br>ALUSrcA = 0 คือ Mux เลือกค่าจาก 0 ซึ่งคือ PC ค่าที่ถูกเขียนใน IR จะมี ALUSrcA ทำการควบคุม
  <br>ALUSrcB = 1 คือ Mux เลือกค่าจาก 1 ซึ่งคือ 4 ค่าที่ถูกเขียนใน IR จะมี ALUSrcB ทำการควบคุม
  <br>ALUOP   = ADD คือ การนำค่า PC มาบวกกับ 4
  <br>PCWrite = 1, PCSource = 1   นำผลลัพธ์การคำนวณเขียนทับที่ PC = PC + 4
  
  ### Cycle 2 Decode & Register Fetch
  ![stateno2](https://image1.slideserve.com/3211244/slide23-n.jpg)
  
  **จากรูปภาพ ตัวหนังสือสีแดง แสดงถึงส่วนที่ทำใน Cycle นี้ ตัวหนังสือสีดำ แสดงถึงส่วนที่ไม่ได้ทำใน Cycle นี้** 
   
   <br>ALUSrcA = 0 คือ Mux เลือกค่าจาก 0 ซึ่งคือ PC 
   <br>ALUSrcB = 3 คือ Mux เลือกค่าจาก 3 ซึ่งคือ Offset 
   <br>ALUop   = 0 คือ ALUop จะทำการควบคุมคำสั่ง ADD
   
  ### Cycle 3 R-Format Execution
  ![stateno3](https://image1.slideserve.com/3211244/slide25-n.jpg)
  
  **จากรูปภาพ ตัวหนังสือสีแดง แสดงถึงส่วนที่ทำใน Cycle นี้ ตัวหนังสือสีดำ แสดงถึงส่วนที่ไม่ได้ทำใน Cycle นี้** 
  
  <br>ALUSrcA = 1 คือ Mux เลือกค่าจาก 1 ซึ่งคือ $rs 
  <br>ALUSrcB = 0 คือ Mux เลือกค่าจาก 0 ซึ่งคือ $rt
  <br>ALUop   = 2 คือ ALUop จะทำการควบคุมคำสั่งให้เป็นไปตามคำสั่งใน IR
  
   ### Cycle 4 R-Format Write Register
  ![stateno4](https://image1.slideserve.com/3211244/slide27-n.jpg)
  
  **จากรูปภาพ ตัวหนังสือสีแดง แสดงถึงส่วนที่ทำใน Cycle นี้ ตัวหนังสือสีดำ แสดงถึงส่วนที่ไม่ได้ทำใน Cycle นี้** 
  
  <br>RegWrite = 1 คือ นำค่าจาก ALUout มาเขียนใน $rd
  <br>MemtoReg = 0 คือ Mux เลือกค่าจาก 0 ซึ่งคือ ALUout
  <br>RegDst   = 1 คือ Mux เลือกค่าจาก 1 ซึ่งคือ $rd
  
  ### งานครั้งที่ 6
  [คลิปงานครั้งที่ 6 อธิบาย State Machine ของ คำสั่งชนิด R-Format](https://www.youtube.com/watch?v=kINS_f38R6I&t=9s)




## สรุปเนื้อหาการบ้านครั้งที่ 7
 **Pipelining**
Pipelining เป็นวิธีการทำคำสั่งที่ช่วยให้ทำไวขึ้น หลักๆคือ 1 คำสั่ง จบในหลายๆ Cycle ถึงแม้ว่าจะทำคำสั่งแรกยังไม่เสร็จแต่สามารถนำคำสั่งถัดไปมาทำงานต่อได้เลย

![pipe1](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/pipelining/laundry1.gif)

จากภาพข้างบนเป็นการเปรียบเทียบการทำงานของคอมพิวเตอร์ในรูปแบบปกติ กล่าวคือ เราให้กองเสื้อผ้าฝั่งซ้ายมือเป็นคำสั่ง จากภาพจะพบว่า เราทำการซักผ้ากอง A แล้วนำไปปั่นแห้งเสร็จจึงจะนำผ้า กอง B มาซักต่อ สามารถอธิบายได้ว่า กว่าที่เราจะทำคำสั่งต่อไปได้นั้นเราต้องทำคำสั่งก่อนหน้าให้เสร็จสมบูรณ์ก่อนถึงจะเริ่มทำคำสั่งถัดไปได้ซึ่งทำให้ใช้เวลาจำนวนมาก









* งานครั้งที่ 7
  [คลิปงานครั้งที่ 7](https://www.youtube.com/watch?v=NQ4u19d90rE&t=1s)
